const ContentsSampleData = {
  "conid": "t2209_aa06s",
  "desid": "d2104_aa02s",
  "cliid": "c2201_aa02s",
  "proid": "p2201_aa04s",
  "contents": {
    "portfolio": {
      "pid": "p208",
      "date": new Date("2022-09-28T07:25:37.802Z"),
      "spaceInfo": {
        "space": "현대 성우아파트",
        "pyeong": 25,
        "region": "경기 용인시",
        "method": "아파트 홈스타일링",
        "budget": "1,000만원"
      },
      "title": {
        "main": "보다 나 같은 공간으로, 현대 성우아파트 25py 홈스타일링",
        "sub": "보다 나 같은 공간으로, 현대 성우아파트 홈스타일링"
      },
      "color": {
        "main": "#ececec",
        "sub": "#d3d2d0",
        "title": "#606060"
      },
      "detailInfo": {
        "photodae": [
          3,
          2
        ],
        "photosg": {
          "first": 1,
          "last": 16
        },
        "slide": [
          1,
          2,
          5,
          6,
          7,
          8,
          12,
          15,
          16
        ],
        "tag": [
          "공간으로",
          "리모델링",
          "상황이라",
          "기본적인",
          "재택근무",
          "거실에서",
          "하셔서",
          "작업실",
          "거실로",
          "빼내어",
          "작업실로",
          "활용하고",
          "드레스룸",
          "미니서재로",
          "목적인",
          "프로젝트였습니다선호하시",
          "스타일로",
          "보아도",
          "있었듯",
          "화이트",
          "그레이로",
          "모노톤",
          "모던한",
          "분위기",
          "추천드릴",
          "때에도",
          "유념하여",
          "선정할",
          "우드톤",
          "가구들도",
          "있었기",
          "all",
          "현대 성우아파트",
          "25평",
          "20평형",
          "경기 용인시",
          "현대",
          "성우아파트",
          "경기",
          "용인시",
          "홈퍼니싱",
          "보다",
          "나",
          "같은",
          "공간으로,",
          "현대",
          "성우아파트",
          "25py",
          "홈스타일링"
        ],
        "service": "홈스타일링",
        "sort": {
          "key8": "690",
          "key9": "220918"
        },
        "tendency": {
          "style": {
            "modern": 8,
            "classic": 1,
            "natural": 6,
            "mixmatch": 3,
            "scandinavian": 6,
            "vintage": 4,
            "oriental": 3,
            "exotic": 2
          },
          "texture": {
            "darkWood": 4,
            "whiteWood": 7,
            "coating": 9,
            "metal": 8
          },
          "color": {
            "darkWood": 4,
            "whiteWood": 8,
            "highContrast": 10,
            "vivid": 5,
            "white": 10,
            "mono": 3,
            "bright": 8,
            "dark": 5
          },
          "density": {
            "maximun": 3,
            "minimum": 7
          }
        }
      },
      "contents": {
        "suggestion": "Designer's\nSuggestion",
        "detail": [
          {
            "title": "init",
            "contents": "고객님의 집은 두 자매가 함께 지내는 공간으로, 3년 전에 리모델링을 하신 상황이라 기본적인 배경과 톤은 마음에 드시는 상황이었어요. 하지만 두 분 모두 재택근무를 하시는 상황이라 거의 모든 것을 거실에서 하셔서 방 안에 있던 작업실 가구를 거실로 빼내어, 거실을 작업실로 활용하고, 각각 방의 용도 변경을 원하셨습니다. 기존 거실을 작업실로, 기존 드레스룸을 작업 공방 겸 미니서재로, 기존 작업실을 드레스룸으로 용도 변경이 주 목적인 프로젝트였습니다.\n\n선호하시는 스타일로는 기본 톤을 보아도 알 수 있었듯이, 블랙 앤 화이트 앤 그레이로 모노톤에 모던한 분위기를 선호하셨습니다. 가구를 추천드릴 때에도 이 점을 유념하여 선정할 수 있도록 하였고, 기존의 우드톤 가구들도 있었기 때문에, 기존 가구와 새 가구의 조화를 유의하였습니다.",
            "photo": []
          },
          {
            "title": "livingroom",
            "contents": "거실은 두 자매의 작업실로 변경하여 모노톤의 분위기를 유지하면서, 트렌디한 무드를 살리려고 했습니다. 우선, 거실의 창가 쪽에 두 분의 작업공간이 될 컴퓨터 책상을 마주 보도록 두고 패브릭 파티션을 두어 깔끔한 작업 공간으로 만들어드렸습니다. 책상 반대편으로는 작업실의 휴게 공간과 같은 느낌으로 작은 소파와 유리 테이블을 두어 간단한 식사와 휴식을 취할 수 있는 공간으로 구성하였고, 러그 및 액자로 포인트를 주었습니다. 반대쪽 tv장은 화이트 금속 가구로 깔끔함을 강조하고, 트렌디한 조명들로 마무리하였습니다. 또, 기존의 커튼 대신 화이트 우드 블라인드로 좀 더 작업 공간의 완성도를 높였습니다.",
            "photo": [
              1,
              2,
              3,
              4,
              5
            ]
          },
          {
            "title": "kitchen",
            "contents": "주방은 다이닝 테이블 없이 기존에도 홈바 형태로 사용 중이셨는데, 다소 낡고 어수선하여 보다 밝은 느낌을 줄 수 있는 작업실의 탕비 공간 컨셉으로, 화이트 홈바를 제안드렸습니다. ㄱ자 형태의 홈바로 구성하여, 키 큰장에는 커피바로 활용하고, 아일랜드장에는 간단한 간식과 지저분한 수납을 깔끔하게 할 수 있도록 하였고, 밝고 경쾌한 분위기의 액자와 펜던트 조명을 교체하였습니다.",
            "photo": [
              6,
              7
            ]
          },
          {
            "title": "bedroom",
            "contents": "침실에 슈퍼 싱글 2대를 사용 중이셨는데, 이 부분은 유지할 가구라고 하셔서 그대로 활용하되, 가구의 배치를 달리하여 좀 더 공간을 확보할 수 있도록 하였고, 전체 공간과 침대의 톤과 마감재가 다르기 때문에, 모노톤 체크 베딩과 액자로 전체적인 흐름과 연결될 수 있도록 하였습니다. 침대 맞은편으로는 기존 거실에 사용 중이셨던 수납장을 두고, 수납장 위로 모던한 느낌의 거울을 두어 화장대 공간으로 활용하였고, 기존 블라인드는 그레이 암막 커튼으로 교체하여 좀 더 포근한 공간으로 제안드렸습니다.",
            "photo": [
              8,
              9,
              10,
              11
            ]
          },
          {
            "title": "workroom",
            "contents": "기존 드레스룸 공간을 소소한 작업을 할 수 있는 공방 겸 미니 서재 느낌으로 변경하길 원하셨습니다. 모든 가구를 다 교체할 수 없는 상황이라, 4인 테이블을 제외하고는 기존 가구를 활용하였습니다. tv장과 수납장 등은 기존 가구를 활용하고, 기존 거실에 있던 피아노와 파티션 역시 이 방으로 옮겨 고객님의 취향과 취미가 묻어나는 공간이 되었습니다. 화이트 테이블 옆 벽면에는 블랙 컬러의 타공판을 추천드려 소품과 작업에 필요한 도구를 거치할 수 있도록 해드렸고, 이 공간 역시 화이트 우드 블라인드로 좁은 방을 보다 넓어 보이고 환해 보일 수 있도록 제안드렸습니다.",
            "photo": [
              12,
              13,
              14
            ]
          },
          {
            "title": "dressroom",
            "contents": "이 방은 기존에 메인 작업실 공간으로 사용 중이셨던 공간인데, 드레스룸 공간으로 변경하셨습니다. 기존 드레스룸 가구가 낡지 않은 상태라 그대로 사이즈에 맞춰 배치하여 옮길 것을 제안드렸고, 추가로 모던한 느낌의 원형 러그와 화이트 블라인드 교체를 통하여 깔끔한 분위기를 강조하였습니다. 획일된 공간의 쓰임보다 각 공간마다 용도 변경을 통하여 보다 나 같고 내가 편한 공간으로 탈바꿈시킨 고객님에게 많은 것을 배운 현장이었습니다 :)",
            "photo": [
              15,
              16
            ]
          }
        ]
      }
    },
    "review": {
      "rid": "re202",
      "date": new Date("2022-09-28T07:25:37.802Z"),
      "title": {
        "main": "상담이라도 받아보자는, 마음에 시작해봤어요.",
        "sub": "상담이라도, 받아보자!"
      },
      "detailInfo": {
        "photodae": [
          9,
          8
        ],
        "order": 570
      },
      "contents": {
        "detail": [
          {
            "type": "init",
            "photos": [],
            "contents": [
              {
                "question": "",
                "answer": "아지트? 사무실? 알쏭달쏭 독특한 공간 용도가 매력적인 집을 소개합니다. 집이란 사용자가 한정된 공간이므로 주인의 생활양식에 맞게 목적을 두면 가장 효율적이고 독창적인 디자인의 인테리어를 완성할 수 있어요. 오늘의 연년생 자매 고객님들도 이 부분에 가장 집중하셨어요. 우리 집을 꾸밀 때에 남의 눈치 보지 마세요! 진정 나에게 맞는 것을 찾아보세요 :)"
              }
            ]
          },
          {
            "type": "contents",
            "photos": [
              8
            ],
            "contents": [
              {
                "question": "홈리에종을 알게 된 경로가 궁금해요.",
                "answer": "홈리에종 사업 초기부터 알고 있었어요. 여기 이사 준비를 하면서부터 봤거든요. 당시에는 홈스타일링이라는 키워드를 검색하면 큰 업체는 홈리에종 뿐이었어요. 하지만 그때는 저희가 리모델링 자금이 부족해서 조금이라도 아껴야 했어요. 또 홈리에종이 초창기에는 으리으리한 대형 주택 위주로 포트폴리오를 가지고 있었거든요. 저희와 같은 20평대도 진행이 가능할 거라고 생각을 못 해서 포기했어요.\n\n그런데 시공만 힘쓰고 가구들의 구색이 안 맞추어진 채로 살다 보니까 도저히 생활이 안 되는 거예요. 저희가 원룸에서 이사했던 상황이라 어차피 대부분 구매했어야 하는데, 그때 같이 맡길 걸 후회도 했고요. 생각이 나서 다시 왔는데 그 사이에 포트폴리오가 엄청 많이 다양하게 쌓였더라고요. “상담이라도 받아보자!”라는 생각으로 찾아왔어요."
              },
              {
                "question": "공간 기획이 특별한데요! 어떤 라이프 스타일을 가진 고객님이신가요?",
                "answer": "저희는 게임 회사에 다녀요. 어쩌다 자매가 같은 회사에 다니고 있어요. 재택 이전에는 출퇴근도 같이 하고, 같이 살고 정말 많이 붙어 있어요. 직무는 게임에 들어가는 그림들을 그리고요. 동생이 저한테 그림을 배운 케이스라서, 처음에는 스타일이 비슷했다가 사람이 다르다 보니까 점점 자기 것이 생기더라고요. 비슷한데 다른 자매입니다."
              }
            ]
          },
          {
            "type": "contents",
            "photos": [
              9,
              10,
              11
            ],
            "contents": [
              {
                "question": "두 분도 디자이너이시군요. 인테리어 디자이너를 선택할 때에 예리하게 보신 점이 있다면?",
                "answer": "(언니) 3D 모델링으로 결과물을 보여주실 수 있는 분을 원했어요. 저희도 나름대로 도면 위에 작업해 보고 이리저리 힘써서 바꿔도 보다가 도저히 답이 안 나와서 전문가를 찾은 상황이었기 때문에 확실하게 예상되는 결과치를 알아야 바꿀 마음이 들고 실행단계로 넘어갈 수 있을 것 같았어요. 그래서 3D가 가능한 디자이너님이라면 무조건 콜! 하는 마음이 있었습니다. 결과적으로 저희도 디자이너이지만 놀라운 정도로 시안과 똑같이 구현이 되었어요.\n\n(동생) 저희 집이 시공 베이스도 공간 기획도 특별한 점이 있잖아요. 3년 전에 시공을 다른 인테리어 업체랑 했을 때에도, 보통은 평이하게 선호도 높은 스타일을 많이 하시다 보니까, 저희가 “바닥은 까맣게 해주세요. 벽은 하얗게 해주세요. 사무실처럼 전자 기기들이 많이 들어가야 하니까 전선을 어떻게 해주세요.” 하면, 저희를 말리거나 감을 잘 못 잡으시더라고요. 그런데 왠지 호지희 디자이너님은 해주실 것 같은 느낌이 들어가지고요. 당시에 시안이 적으셨지만, 고객님이 원하는 것을 반영해 드린 느낌이 있었어요."
              }
            ]
          },
          {
            "type": "contents",
            "photos": [
              1,
              2,
              3,
              4,
              5
            ],
            "contents": [
              {
                "question": "오로지 두 분만을 위한 공간이네요.",
                "answer": "디자이너님이 니즈를 잘 캐치하고 반영해 주셔서 가능했어요. 사실 좁은 거실에 TV도 있고 게임기도 많은데 책상까지 두 개를 배치하는 것이 쉬운 일이 아니에요. 게다가 “소파도 넣어주세요~ 거기서 밥도 먹어야 하니까 테이블도 넣어주세요~” 이러니까, 아마 디자이너님이 속으로 당황하셨을 수도 있어요. 좁은 곳에 다 넣고자 하니까 어려운 작업이었을 텐데 적극적으로 해주셨어요. 특히 거실장은 세 네 번 정도 디벨롭했거든요. 그런데 그때마다 새로운, 더 좋은 방안을 제안해 주셨어요."
              },
              {
                "question": "가장 마음에 드는 공간은 어디인가요?",
                "answer": "거실이죠! 다른 공간도 마음에 들지만, 어떤 분이 하셨어도 잘 해주셨을 수도 있어요. 흔한 용도이니까요. 그런데 거실은 정말 저희가 원했던 모든 기능이 들어가면서, 까다로운 저희 언니가 만족했을 정도이고요. 밀도가 정말 높은데 지내보면 동선이 불편하거나 공간감이 답답하지도 않아요."
              }
            ]
          },
          {
            "type": "contents",
            "photos": [
              7,
              8
            ],
            "contents": [
              {
                "question": "거주 중 진행에 대한 tip을 공유해 주세요!",
                "answer": "(언니) 동생이 홈스타일링을 하자고 했을 때 저는 귀찮다고 회의적이었어요. 이사를 다닐 때마다 싫고 힘들었던 기억이 있어요. 이제는 자가로 정착해서 편히 지내고 있었으니까, 나는 손도 하나 까딱 안 할 거고 네가 알아서 하라며 시작했어요. 하다 보니까 저도 협조를 할 수밖에 없더라고요. 대신 저희는 에너지를 줄이려고 돈을 썼습니다. 돈을 조금만 더 쓰면 우리 몸이 편하다 생각해서 정리 수납도 업체를 부르고, 가구 옮겨주는 용역도 불렀어요. 그런데 역시 뭐든지 전문가가 좋아요. 단순히 가구를 옮겨주신 게 아니라 수평도 딱 딱 맞춰서 조립해 주시고, 정리 수납도 받고 나니 감탄이 나오더라고요. 거주 중에도 해결할 수 있는 방안들이 다 존재해요.\n\n(동생) 현실의 제약이 있더라도, 열린 마음으로 제안을 받아보시면 더 좋은 경험을 하실 수 있을 거예요. 저희도 워낙 큰 가구가 많았잖아요. 기존 제품을 살리거나 큰 이동을 줄이는 것을 최우선으로 요청드리면, 디자이너님이 구상하시기에 제약이 많으신 것 같은 거예요. 사실 원하는 대로 바꾸려면 폐기 비용도 들어가고, 또 사는 비용도 들어가니까 고려를 안 할 수는 없지만요. 경우에 따라 약간 더 수용해 보자는 열린 마음이요! 저희는 디자이너님께 중간에 의사를 확실히 말씀드렸어요. “가구 버리고 옮기는 거는 저희가 어떻게든 해볼 테니까 자유롭게 작업해 주세요.”했는데 확 달랐어요."
              }
            ]
          },
          {
            "type": "contents",
            "photos": [
              12,
              13,
              14
            ],
            "contents": [
              {
                "question": "초대하셨던 손님들 반응이 어떤가요?",
                "answer": "지금 인터뷰하고 있는 이 방은 놀려고 만든 아지트예요. 이미 친구들이 놀러 왔었고요! 올 때마다 너무 부러워하고 즐겁게 놀고 가요. 주변에 엄청 자랑하고 있어요."
              }
            ]
          },
          {
            "type": "contents",
            "photos": [
              15,
              16
            ],
            "contents": [
              {
                "question": "마지막 소감 부탁드려요.",
                "answer": "솔직히 저희는 강한 의지로 진행했지만, 어떤 분들은 관심이 있다가도 현실적으로 어렵다고 판단하고 포기하는 일이 꽤 많을 것 같아요. 하지만 살면서 계속 불편하고 답이 안 나와서 진짜 필요하다고 느끼시는 분들은 과감히 진행해 보세요. 일단 상담부터 해보세요. 저희 케이스가 좋은 선례가 되면 좋겠네요. 저 너무 마음에 들어요. 강력하게 만족합니다."
              }
            ]
          }
        ]
      }
    }
  },
  "photos": {
    "first": 1,
    "last": 16,
    "detail": [
      {
        "index": 1,
        "gs": "g"
      },
      {
        "index": 2,
        "gs": "g"
      },
      {
        "index": 3,
        "gs": "s"
      },
      {
        "index": 4,
        "gs": "s"
      },
      {
        "index": 5,
        "gs": "g"
      },
      {
        "index": 6,
        "gs": "g"
      },
      {
        "index": 7,
        "gs": "g"
      },
      {
        "index": 8,
        "gs": "g"
      },
      {
        "index": 9,
        "gs": "s"
      },
      {
        "index": 10,
        "gs": "s"
      },
      {
        "index": 11,
        "gs": "g"
      },
      {
        "index": 12,
        "gs": "g"
      },
      {
        "index": 13,
        "gs": "s"
      },
      {
        "index": 14,
        "gs": "s"
      },
      {
        "index": 15,
        "gs": "g"
      },
      {
        "index": 16,
        "gs": "g"
      }
    ]
  },
  "service": {
    "serid": "s2011_aa01s",
    "xValue": "B",
    "online": false
  }
}

const ContentsMap = {
  main: function () {
    let dummy;
    dummy = {
      structure: {
        conid: "",
        desid: "",
        cliid: "",
        proid: "",
        contents: {
          portfolio: {
            pid: "",
            date: new Date(1800, 0, 1),
            spaceInfo: {
              space: "",
              pyeong: 0,
              region: "",
              method: "",
              budget: "3,000만원",
            },
            title: {
              main: "",
              sub: "",
            },
            color: {
              main: "",
              sub: "",
              title: "",
            },
            detailInfo: {
              photodae: [],
              photosg: {
                first: 0,
                last: 0,
              },
              slide: [],
              tag: [],
              service: "",
              sort: {
                key8: 0,
                key9: 0,
              },
              tendency: {
                style: {
                  modern: 0,
                  classic: 0,
                  natural: 0,
                  mixmatch: 0,
                  scandinavian: 0,
                  vintage: 0,
                  oriental: 0,
                  exotic: 0,
                },
                texture: {
                  darkWood: 0,
                  whiteWood: 0,
                  coating: 0,
                  metal: 0
                },
                color: {
                  darkWood: 0,
                  whiteWood: 0,
                  highContrast: 0,
                  vivid: 0,
                  white: 0,
                  mono: 0,
                  bright: 0,
                  dark: 0,
                },
                density: {
                  maximun: 0,
                  minimum: 0,
                }
              },
            },
            contents: {
              suggestion: "Designer's\nSuggestion",
              detail: [],
            }
          },
          review: {
            rid: "",
            date: new Date(1800, 0, 1),
            title: {
              main: "",
              sub: "",
            },
            detailInfo: {
              photodae: [],
              order: 0,
            },
            contents: {
              detail: [],
            }
          }
        },
        photos: {
          first: 0,
          last: 0,
          detail: [],
        },
        service: {
          serid: "s2011_aa02s",
          xValue: "B",
          online: false,
        },
      }
    };
    return dummy;
  },
  sub: function (subject) {
    let dummy = null;
    if (subject === "contents.portfolio.contents.detail") {
      dummy = {
        photo: [],
        title: "",
        contents: "",
      };
    } else if (subject === "contents.review.contents.detail") {
      dummy = {
        type: "",
        photos: [],
        contents: [
          {
            question: "",
            answer: "",
          }
        ]
      };
    } else if (subject === "photos.detail") {
      dummy = { index: 0, gs: 'g' };
    }
    return dummy;
  }
}

/**
 * @class DateParse
 * Date 클래스를 확장하여 날짜 처리 기능을 제공하는 클래스입니다.
 * 문자열 형식의 날짜를 Date 객체로 변환하거나, Date 객체를 다양한 형식으로 변환할 수 있습니다.
 */
class DateParse extends Date {

  /**
   * @constructor
   * 주어진 dateObject를 Date 객체로 변환하여 초기화합니다.
   * 문자열 형식의 날짜가 주어진 경우, 해당 문자열을 분석하여 Date 객체로 변환합니다.
   * @param {string|Date} dateObject - 변환할 날짜 문자열 또는 Date 객체
   * @throws {Error} 유효하지 않은 날짜 형식이 주어진 경우 예외를 발생시킵니다.
   */
  constructor(dateObject) {
    // 임시 배열 변수를 선언합니다.
    let tempArr0, tempArr1, tempArr2;

    // dateObject가 문자열인 경우
    if (typeof dateObject === "string") {
      // 날짜 문자열이 "YYYY-MM-DD HH:MM:SS" 형식인 경우
      if (dateObject.length === 19) {
        // 날짜와 시간을 분리하여 tempArr0에 저장합니다.
        tempArr0 = dateObject.split(" ");
        // 날짜 부분을 "-"로 분리하여 tempArr1에 저장합니다.
        tempArr1 = tempArr0[0].split("-");
        // 시간 부분을 ":"로 분리하여 tempArr2에 저장합니다.
        tempArr2 = tempArr0[1].split(":");
        // 분리된 연, 월, 일, 시, 분, 초 정보를 이용해 Date 객체를 생성하고, 상위 클래스(Date)의 생성자를 호출합니다.
        super(new Date(
          Number(tempArr1[0]), 
          Number(tempArr1[1]) - 1, 
          Number(tempArr1[2]), 
          Number(tempArr2[0]), 
          Number(tempArr2[1]), 
          Number(tempArr2[2])
        ));
      } 
      // 날짜 문자열이 "YYYY-MM-DD" 형식인 경우
      else if (dateObject.length === 10) {
        // 날짜를 "-"로 분리하여 tempArr1에 저장합니다.
        tempArr1 = dateObject.split("-");
        // 분리된 연, 월, 일 정보를 이용해 Date 객체를 생성하고, 상위 클래스(Date)의 생성자를 호출합니다.
        super(new Date(
          Number(tempArr1[0]), 
          Number(tempArr1[1]) - 1, 
          Number(tempArr1[2])
        ));
      } 
      // 유효하지 않은 날짜 형식인 경우
      else {
        // 예외를 발생시킵니다.
        throw new Error("invalid date object");
      }
    } 
    // dateObject가 문자열이 아닌 경우
    else {
      // dateObject를 ISO 문자열로 변환한 후 Date 객체로 초기화합니다.
      super(dateObject.toISOString());
    }
  }

  /**
   * @method zeroAddition
   * 숫자가 10보다 작은 경우 앞에 0을 추가하여 2자리 문자열로 반환합니다.
   * @param {number} number - 2자리로 변환할 숫자
   * @returns {string} 2자리 숫자 문자열
   */
  static zeroAddition(number) {
    // 숫자가 10보다 큰 경우 그대로 문자열로 반환합니다.
    if (number > 9) {
      return String(number);
    } 
    // 숫자가 10보다 작은 경우 앞에 0을 추가하여 문자열로 반환합니다.
    else {
      return '0' + String(number);
    }
  }

  /**
   * @method toString
   * Date 객체를 "YYYY-MM-DD" 또는 "YYYY-MM-DD HH:MM:SS" 형식의 문자열로 변환합니다.
   * @param {boolean} [detail=false] - 시간 정보까지 포함할지 여부
   * @returns {string} 변환된 날짜 문자열
   */
  toString(detail = false) {
    // 연도, 월, 일, 시, 분, 초 정보를 각각 추출합니다.
    const year = this.getFullYear();
    const month = this.getMonth() + 1;
    const day = this.getDate();
    const hours = this.getHours();
    const minutes = this.getMinutes();
    const seconds = this.getSeconds();

    // detail이 true인 경우 "YYYY-MM-DD HH:MM:SS" 형식으로 변환합니다.
    if (detail) {
      // 연도가 1800년인 경우 "1800-01-01"로 반환합니다.
      if (year === 1800) {
        return "1800-01-01";
      } 
      // 그렇지 않으면 연, 월, 일, 시, 분, 초를 모두 포함한 문자열을 반환합니다.
      else {
        return (
          DateParse.zeroAddition(year) + "-" + 
          DateParse.zeroAddition(month) + "-" + 
          DateParse.zeroAddition(day) + " " + 
          DateParse.zeroAddition(hours) + ":" + 
          DateParse.zeroAddition(minutes) + ":" + 
          DateParse.zeroAddition(seconds)
        );
      }
    } 
    // detail이 false인 경우 "YYYY-MM-DD" 형식으로 변환합니다.
    else {
      // 연도가 1800년인 경우 "1800-01-01"로 반환합니다.
      if (year === 1800) {
        return "1800-01-01";
      } 
      // 그렇지 않으면 연, 월, 일만 포함한 문자열을 반환합니다.
      else {
        return (
          DateParse.zeroAddition(year) + "-" + 
          DateParse.zeroAddition(month) + "-" + 
          DateParse.zeroAddition(day)
        );
      }
    }
  }

  /**
   * @method toNormal
   * DateParse 객체를 일반 Date 객체로 변환합니다.
   * @returns {Date} 변환된 Date 객체
   */
  toNormal() {
    // 현재 객체의 ISO 문자열 표현을 사용하여 새로운 Date 객체를 반환합니다.
    return new Date(this.toISOString());
  }

  /**
   * @method toSixString
   * Date 객체를 "YYMMDD" 형식의 6자리 문자열로 변환합니다.
   * @returns {string} 변환된 6자리 날짜 문자열
   */
  toSixString() {
    // 날짜를 "YYYY-MM-DD" 형식의 문자열로 변환한 후, 앞 두 자리를 제외한 "YYMMDD" 형식으로 잘라서 반환합니다.
    let date = this.toString(false);
    return (date.slice(2, 4) + date.slice(5, 7) + date.slice(8, 10));
  }

}

/**
 * @class Menu
 * @extends String
 * @description 주어진 값들 중 하나 또는 여러 개를 선택하여 관리하는 클래스입니다. Enum과 유사한 역할을 하며, 단일 선택 또는 다중 선택 모드를 지원합니다.
 */
class Menu extends String {

  /**
   * @constructor
   * @param {string|string[]} value - 초기 값 또는 값들의 배열입니다.
   * @param {string[]} items - 선택 가능한 값들의 배열입니다.
   * @param {boolean} [multiple=false] - 다중 선택 모드 여부를 지정합니다. 기본값은 false입니다.
   * @description 주어진 값이 유효한지 검사하고, 유효하다면 해당 값을 설정합니다. 다중 선택 모드인 경우, 유효한 값들만 필터링하여 저장합니다.
   */
  constructor(value, items, multiple = false) {
    // value가 배열인 경우 빈 문자열로 초기화하고, 그렇지 않으면 해당 값을 상위 클래스(String)로 전달하여 초기화합니다.
    if (Array.isArray(value)) {
      super(''); // 다중 선택 모드에서 상위 클래스(String)를 빈 문자열로 초기화합니다.
    } else {
      super(value); // 단일 선택 모드에서 상위 클래스(String)를 주어진 값으로 초기화합니다.
    }

    this.value = null; // 단일 선택된 값을 저장하기 위한 속성입니다. 초기값은 null입니다.
    this.values = null; // 다중 선택된 값들을 저장하기 위한 속성입니다. 초기값은 null입니다.
    this.items = items; // 선택 가능한 값들의 목록을 items 속성에 저장합니다.

    let temp; // 임시 배열을 선언합니다. 다중 선택 모드에서 사용됩니다.

    // 단일 선택 모드인 경우
    if (!multiple) {
      // 주어진 값이 선택 가능한 값 목록에 포함되어 있는지 확인합니다.
      if (items.includes(value)) {
        this.value = value; // 포함되어 있다면 해당 값을 value 속성에 저장합니다.
      } else {
        this.value = "알 수 없음"; // 포함되어 있지 않다면 "알 수 없음"을 value 속성에 저장합니다.
      }
    }
    // 다중 선택 모드인 경우
    else {
      temp = []; // 임시 배열을 빈 배열로 초기화합니다.
      for (let i of value) { // 주어진 값 배열에서 각 값을 반복합니다.
        if (items.includes(i)) { // 각 값이 선택 가능한 값 목록에 포함되어 있는지 확인합니다.
          temp.push(i); // 포함되어 있다면 임시 배열에 추가합니다.
        }
      }
      this.values = temp; // 필터링된 값을 values 속성에 저장합니다.
    }
  }

  /**
   * @method toNormal
   * @description 현재 선택된 값을 반환합니다. 단일 선택 모드인 경우 단일 값을 반환하고, 다중 선택 모드인 경우 선택된 값들의 배열을 반환합니다.
   * @returns {string|string[]} 선택된 값 또는 값들의 배열을 반환합니다.
   */
  toNormal() {
    if (this.values === null) { // 다중 선택된 값이 없는 경우 (단일 선택 모드)
      return this.value; // 단일 값을 반환합니다.
    } else {
      return this.values; // 다중 선택된 값들의 배열을 반환합니다.
    }
  }
  
}

class Contents {
  constructor (json) {
    this.conid = json.conid;
    this.desid = json.desid;
    this.cliid = json.cliid;
    this.proid = json.proid;
    this.contents = new this.#ContentsTong(json.contents);
    this.photos = new this.#PhotoTong(json.photos);
    this.service = new this.#Service(json.service);
  }

  #Service = class {
    constructor (json) {
      this.serid = json.serid;
      this.xValue = json.xValue;
      this.online = Boolean(json.online);
    }

    toNormal () {
      let obj = {};
      obj.serid = this.serid;
      obj.xValue = this.xValue;
      obj.online = this.online;
      return obj;
    }
  }

  #PhotoTong = class {
    constructor (json) {
      this.first = json.first;
      this.last = json.last;
      let arr, temp;
      arr = new this.#PhotoDetails();
      for (let i of json.detail) {
        temp = new this.#PhotoDetail(i);
        arr.push(temp);
      }
      this.detail = arr;
    }
  
    toNormal () {
      let obj = {};
      obj.first = Number(this.first);
      obj.last = Number(this.last);
      obj.detail = this.detail.toNormal();
      return obj;
    }
  
    #PhotoDetail = class {
      constructor (json) {
        this.index = json.index;
        this.gs = json.gs;
      }
    
      toNormal () {
        let obj = {};
        obj.index = Number(this.index);
        obj.gs = this.gs;
        return obj;
      }
    }
    
    #PhotoDetails = class extends Array {
      toNormal() {
        let arr = [];
        for (let i of this) {
          arr.push(i.toNormal());
        }
        return arr;
      }
    }
  }

  #ContentsTong = class {
    constructor (json) {
      this.portfolio = new this.#Porfolio(json.portfolio);
      this.review = new this.#Review(json.review);
    }
  
    toNormal () {
      let obj = {};
      obj.portfolio = this.portfolio.toNormal();
      obj.review = this.review.toNormal();
      return obj;
    }

    #Review = class {
      constructor (json) {
        this.rid = json.rid;
        this.date = new DateParse(json.date);
        this.title = new this.#Title(json.title);
        this.detailInfo = new this.#ReviewDetailInfo(json.detailInfo);
        this.contents = new this.#ReviewContents(json.contents);
      }
    
      toNormal () {
        let obj = {};
        obj.rid = this.rid;
        obj.date = this.date.toNormal();
        obj.title = this.title.toNormal();
        obj.detailInfo = this.detailInfo.toNormal();
        obj.contents = this.contents.toNormal();
        return obj;
      }
    
      #ReviewDetailInfo = class {
        constructor (json) {
          let arr0;
          arr0 = new this.#Photodae();
          for (let i of json.photodae) {
            arr0.push(i);
          }
          this.photodae = arr0;
          this.order = json.order;
        }
      
        toNormal () {
          let obj = {};
          obj.photodae = this.photodae.toNormal();
          obj.order = this.order;
          return obj;
        }
      
        #Photodae = class extends Array {
          toNormal() {
            let arr = [];
            for (let i of this) {
              arr.push(i);
            }
            return arr;
          }
        }
      }
      
      #ReviewContents = class {
        constructor (json) {
          let temp, arr;
          arr = new this.#ReviewContentsDetails();
          for (let i of json.detail) {
            temp = new this.#ReviewContentsDetail(i);
            arr.push(temp);
          }
          this.detail = arr;
        }
      
        toNormal () {
          let obj = {};
          obj.detail = this.detail.toNormal();
          return obj;
        }
      
        #ReviewContentsDetail = class {
          constructor (json) {
            let arr0, arr1;
            let temp;
            arr0 = new this.#Photos();
            arr1 = new this.#QuestionAnswers();
            for (let i of json.photos) {
              arr0.push(i);
            }
            for (let i of json.contents) {
              temp = new this.#QuestionAnswer(i);
              arr1.push(temp);
            }
            this.type = json.type;
            this.photos = arr0;
            this.contents = arr1;
          }
        
          toNormal () {
            let obj = {};
            obj.type = this.type;
            obj.photos = this.photos.toNormal();
            obj.contents = this.contents.toNormal();
            return obj;
          }
        
          #QuestionAnswer = class {
            constructor (json) {
              this.question = json.question;
              this.answer = json.answer;
            }
          
            toNormal () {
              let obj = {};
              obj.question = this.question;
              obj.answer = this.answer;
              return obj;
            }
          }
          
          #Photos = class extends Array {
            toNormal() {
              let arr = [];
              for (let i of this) {
                arr.push(i);
              }
              return arr;
            }
          }
          
          #QuestionAnswers = class extends Array {
            toNormal() {
              let arr = [];
              for (let i of this) {
                arr.push(i.toNormal());
              }
              return arr;
            }
          }
        }
        
        #ReviewContentsDetails = class extends Array {
          toNormal() {
            let arr = [];
            for (let i of this) {
              arr.push(i.toNormal());
            }
            return arr;
          }
        }
      }
      
      #Title = class {
        constructor (json) {
          this.main = json.main;
          this.sub = json.sub;
        }
      
        toNormal () {
          let obj = {};
          obj.main = this.main;
          obj.sub = this.sub;
          return obj;
        }
        
        getAllCases () {
          let obj = {};
          obj.main = [];
          obj.main.push(this.main);
          obj.main.push(this.main.replace(/, /, "\n"));
          obj.sub = [];
          obj.sub.push(this.sub.replace(/, /, " "));
          obj.sub.push(this.sub.replace(/, /, "\n"));
          return obj;
        }
      }
    }

    #Porfolio = class {
      constructor (json) {
        this.pid = json.pid;
        this.date = new DateParse(json.date);
        this.spaceInfo = new this.#SpaceInfo(json.spaceInfo);
        this.title = new this.#Title(json.title);
        this.color = new this.#Color(json.color);
        this.detailInfo = new this.#PorfolioDetailInfo(json.detailInfo);
        this.contents = new this.#PorfolioContents(json.contents);
      }
    
      toNormal () {
        let obj = {};
        obj.pid = this.pid;
        obj.date = this.date.toNormal();
        obj.spaceInfo = this.spaceInfo.toNormal();
        obj.title = this.title.toNormal();
        obj.color = this.color.toNormal();
        obj.detailInfo = this.detailInfo.toNormal();
        obj.contents = this.contents.toNormal();
        return obj;
      }
      
      #PorfolioContents = class {
        constructor (json) {
          let temp;
          let arr = new this.#PorfolioContentsDetails();
          for (let i of json.detail) {
            temp = new this.#PorfolioContentsDetail(i);
            arr.push(temp);
          }
          this.suggestion = json.suggestion;
          this.detail = arr;
        }
      
        toNormal () {
          let obj = {};
          obj.suggestion = this.suggestion;
          obj.detail = this.detail.toNormal();
          return obj;
        }
      
        keyMatrix () {
          return this.detail.keyMatrix();
        }
      
        #PorfolioContentsDetail = class {
          constructor (json) {
            this.photo = json.photo;
            this.title = json.title;
            this.contents = json.contents;
          }
        
          toNormal () {
            let obj = {};
            obj.photo = this.photo;
            obj.title = this.title;
            obj.contents = this.contents;
            return obj;
          }
        }
        
        #PorfolioContentsDetails = class extends Array {
          toNormal() {
            let arr = [];
            for (let i of this) {
              arr.push(i.toNormal());
            }
            return arr;
          }
        
          keyMatrix() {
            let result = {};
            let arr = [];
            let tempArr;
            result.rooms = [];
            for (let i = 1; i < this.length; i++) {
              tempArr = this[i].photo;
              arr.push(tempArr);
              result.rooms.push(this[i].title);
            }
            result.photos = arr;
            return result;
          }
        }
      }
      
      #PorfolioDetailInfo = class {
        constructor (json) {
          let arr0, arr1, arr2;
          arr0 = new this.#Photodae();
          arr1 = new this.#Slide();
          arr2 = new this.#Tag();
          for (let i of json.photodae) {
            arr0.push(i);
          }
          for (let i of json.slide) {
            arr1.push(i);
          }
          for (let i of json.tag) {
            arr2.push(i);
          }
          this.photodae = arr0;
          this.photosg = new this.#Photosg(json.photosg);
          this.slide = arr1;
          this.tag = arr2;
          this.service = json.service;
          this.sort = new this.#Sort(json.sort);
          this.tendency = new this.#StylingTendency(json.tendency);
        }
      
        toNormal () {
          let obj = {};
          obj.photodae = this.photodae.toNormal();
          obj.photosg = this.photosg.toNormal();
          obj.slide = this.slide.toNormal();
          obj.tag = this.tag.toNormal();
          obj.service = this.service;
          obj.sort = this.sort.toNormal();
          obj.tendency = this.tendency.toNormal();
          return obj;
        }
      
        #Slide = class extends Array {
          toNormal() {
            let arr = [];
            for (let i of this) {
              arr.push(i);
            }
            return arr;
          }
        }
      
        #Photodae = class extends Array {
          toNormal() {
            let arr = [];
            for (let i of this) {
              arr.push(i);
            }
            return arr;
          }
        }
      
        #Tag = class extends Array {
          toNormal() {
            let arr = [];
            for (let i of this) {
              arr.push(i);
            }
            return arr;
          }
        }
      
        #Photosg = class {
          constructor (json) {
            this.first = Number(json.first);
            this.last = Number(json.last);
          }
          toNormal () {
            let obj = {};
            obj.first = Number(this.first);
            obj.last = Number(this.last);
            return obj;
          }
        }
        
        #Sort = class {
          constructor (json) {
            this.key8 = json.key8;
            this.key9 = json.key9;
          }
          toNormal () {
            let obj = {};
            obj.key8 = this.key8;
            obj.key9 = this.key9;
            return obj;
          }
        }
      
        #StylingTendency = class {
          constructor (json) {
            this.style = new this.#TendencyStyle(json.style);
            this.texture = new this.#TendencyTexture(json.texture);
            this.color = new this.#TendencyColor(json.color);
            this.density = new this.#TendencyDensity(json.density);
          }
        
          toNormal () {
            let obj = {};
            obj.style = this.style.toNormal();
            obj.texture = this.texture.toNormal();
            obj.color = this.color.toNormal();
            obj.density = this.density.toNormal();
            return obj;
          }
          
          toMatrix (keymode = false) {
            const keys = [ "style", "texture", "color", "density" ];
            const keyArr = [
              [
                "modern",
                "classic",
                "natural",
                "mixmatch",
                "scandinavian",
                "vintage",
                "oriental",
                "exotic",
              ],
              [
                "darkWood",
                "whiteWood",
                "coating",
                "metal",
              ],
              [
                "darkWood",
                "whiteWood",
                "highContrast",
                "vivid",
                "white",
                "mono",
                "bright",
                "dark",
              ],
              [
                "maximun",
                "minimum",
              ]
            ];
            let result;
            result = [];
            for (let i = 0; i < keys.length; i++) {
              for (let key of keyArr[i]) {
                result.push(this[keys[i]][key]);
              }
            }
            if (keymode) {
              return keyArr.flat();
            } else {
              return result;
            }
          }
        
          #TendencyDensity = class {
            constructor (json) {
              this.maximun = json.maximun;
              this.minimum = json.minimum;
            }
          
            toNormal () {
              let obj = {};
              obj.maximun = this.maximun;
              obj.minimum = this.minimum;
              return obj;
            }
          }
          
          #TendencyColor = class {
            constructor (json) {
              this.darkWood = json.darkWood;
              this.whiteWood = json.whiteWood;
              this.highContrast = json.highContrast;
              this.vivid = json.vivid;
              this.white = json.white;
              this.mono = json.mono;
              this.bright = json.bright;
              this.dark = json.dark;
            }
          
            toNormal () {
              let obj = {};
              obj.darkWood = this.darkWood;
              obj.whiteWood = this.whiteWood;
              obj.highContrast = this.highContrast;
              obj.vivid = this.vivid;
              obj.white = this.white;
              obj.mono = this.mono;
              obj.bright = this.bright;
              obj.dark = this.dark;
              return obj;
            }
          }
          
          #TendencyTexture = class {
            constructor (json) {
              this.darkWood = json.darkWood;
              this.whiteWood = json.whiteWood;
              this.coating = json.coating;
              this.metal = json.metal;
            }
          
            toNormal () {
              let obj = {};
              obj.darkWood = this.darkWood;
              obj.whiteWood = this.whiteWood;
              obj.coating = this.coating;
              obj.metal = this.metal;
              return obj;
            }
          }
          
          #TendencyStyle = class {
            constructor (json) {
              this.modern = json.modern;
              this.classic = json.classic;
              this.natural = json.natural;
              this.mixmatch = json.mixmatch;
              this.scandinavian = json.scandinavian;
              this.vintage = json.vintage;
              this.oriental = json.oriental;
              this.exotic = json.exotic;
            }
          
            toNormal () {
              let obj = {};
              obj.modern = this.modern;
              obj.classic = this.classic;
              obj.natural = this.natural;
              obj.mixmatch = this.mixmatch;
              obj.scandinavian = this.scandinavian;
              obj.vintage = this.vintage;
              obj.oriental = this.oriental;
              obj.exotic = this.exotic;
              return obj;
            }
          }
        }
      
      }
      
      #SpaceInfo = class {
        constructor (json) {
          this.space = json.space;
          this.pyeong = Number(json.pyeong);
          this.region = json.region;
          this.method = json.method;
          this.budget = json.budget;
        }
      
        toNormal () {
          let obj = {};
          obj.space = this.space;
          obj.pyeong = Number(this.pyeong);
          obj.region = this.region;
          obj.method = this.method;
          obj.budget = this.budget;
          return obj;
        }
      }
      
      #Title = class {
        constructor (json) {
          this.main = json.main;
          this.sub = json.sub;
        }
        toNormal () {
          let obj = {};
          obj.main = this.main;
          obj.sub = this.sub;
        
          return obj;
        }
        getAllCases () {
          let obj = {};
          let tempArr, tempArr2, temp, tempResult;
          let pyIndex;
        
          obj.main = [];
          obj.main.push(this.main);
          obj.main.push(this.main.replace(/, /, "\n"));
        
          tempArr = this.main.split(", ");
          obj.main.push(tempArr[1]);
        
          tempArr2 = tempArr[1].split(" ");
          pyIndex = 0;
          for (let i = 0; i < tempArr2.length; i++) {
            if (/py/gi.test(tempArr2[i])) {
              pyIndex = i;
            }
          }
        
          tempResult = '';
          temp = '';
          for (let i = 0; i < pyIndex; i++) {
            temp += tempArr2[i] + ' ';
          }
          tempResult = temp.slice(0, -1);
        
          temp = '';
          for (let i = pyIndex; i < tempArr2.length; i++) {
            temp += tempArr2[i] + ' ';
          }
          tempResult = tempResult + "\n" + temp.slice(0, -1);
          obj.main.push(tempResult);
        
          obj.sub = [];
          obj.sub.push(this.sub);
          obj.sub.push(this.sub.replace(/, /, "\n"));
        
          return obj;
        }
      }
      
      #Color = class {
        constructor (json) {
          this.main = json.main;
          this.sub = json.sub;
          this.title = json.title;
        }
        toNormal () {
          let obj = {};
          obj.main = this.main;
          obj.sub = this.sub;
          obj.title = this.title;
          return obj;
        }
      }
    
      keyMatrix () {
        return this.contents.keyMatrix();
      }
    }
  }

  toNormal () {
    let obj = {};
    obj.conid = this.conid;
    obj.desid = this.desid;
    obj.cliid = this.cliid;
    obj.proid = this.proid;
    obj.contents = this.contents.toNormal();
    obj.photos = this.photos.toNormal();
    obj.service = this.service.toNormal();
    return obj;
  }
  
  toJson = () => {
    return JSON.stringify(this.toNormal(), null, 2);
  }
  
  toDeath = () => {
    return JSON.stringify(this.toNormal(), null, 2);
  }
  
  getTitle = (main = "portfolio", sub = "main") => {
    const { contents: { portfolio, review } } = this;
    switch (main) {
      case "portfolio":
        switch (sub) {
          case "main":
            return portfolio.title.main;
            break;
          case "sub":
            return portfolio.title.sub;
            break;
        }
        break;
      case "review":
        switch (sub) {
          case "main":
            return review.title.main;
            break;
          case "sub":
            return review.title.sub;
            break;
        }
        break;
    }
  }
  
  returnTitleObject = () => {
    const { contents: { portfolio: { title: portfolioTitle }, review: { title: reviewTitle } } } = this;
    let obj = {};
    obj.portfolio = portfolioTitle.getAllCases();
    obj.review = reviewTitle.getAllCases();
    return obj;
  }
  
  getSpace = () => {
    const { contents: { portfolio: { spaceInfo } } } = this;
    return spaceInfo.space;
  }
  
  getPyeong = () => {
    const { contents: { portfolio: { spaceInfo } } } = this;
    return spaceInfo.pyeong;
  }
  
  getRegion = () => {
    const { contents: { portfolio: { spaceInfo } } } = this;
    return spaceInfo.region;
  }
  
  getMethod = () => {
    const { contents: { portfolio: { spaceInfo } } } = this;
    return spaceInfo.method;
  }
  
  getPid = () => {
    return this.contents.portfolio.pid;
  }
  
  getRid = () => {
    return this.contents.review.rid;
  }
  
  toOriginalPath = () => {
    let arr = [];
    for (let i = 0; i < this.photos.detail.length; i++) {
      arr.push(`/corePortfolio/original/${this.contents.portfolio.pid}/i${String(i + 1)}${this.contents.portfolio.pid}.jpg`);
    }
    return arr;
  }
  
  getPortfolioDetail = () => {
    return this.contents.portfolio.contents.detail;
  }
  
  getReviewDetail = () => {
    return this.contents.review.contents.detail;
  }
  
  getGsArr = () => {
    let arr = [];
    for (let { gs } of this.photos.detail) {
      arr.push(gs);
    }
    return arr;
  }
  
  getContentsFlatDetail = () => {
    const { contents: { portfolio: { contents: { detail: portfolioDetail } }, review: { contents: { detail: reviewDetail } } } } = this;
    let portfolio, review;
    let pastKey = null;
  
    portfolio = "";
    for (let { photo, title, contents, smallTalk: { title: smallTalkTitle, contents: smallTalkContents } } of portfolioDetail) {
      if (pastKey !== null) {
        portfolio += photo.join(", ");
        portfolio += "\n\n";
        portfolio += title;
        portfolio += "\n\n";
      }
      portfolio += contents;
      if (smallTalkTitle !== "") {
        portfolio += "\n\n";
        portfolio += smallTalkTitle;
        portfolio += "\n";
        portfolio += smallTalkContents;
      }
      portfolio += "\n\n";
    }
    portfolio = portfolio.slice(0, -2);
  
    review = "";
    for (let { type, photos, contents } of reviewDetail) {
      if (type === "init") {
        for (let { answer } of contents) {
          review += answer;
          review += "\n\n";
        }
      } else {
        review += photos.join(" ");
        review += "\n\n";
        for (let { question, answer } of contents) {
          review += "Q. " + question;
          review += "\n\n";
          review += "A. " + answer;
          review += "\n\n";
        }
      }
    }
    review = review.slice(0, -2);
  
    return { portfolio, review };
  }
  
  getGoogleDocsDetail = (server) => {
    if (typeof server !== "string") {
      throw new Error("server address must")
    }
    const self = this;
    const corePortfolio = "/corePortfolio/listImage";
    const photoChar = 't';
    const { portfolio, review } = this.getContentsFlatDetail();
    const token = "___split___";
    let tempArr, tempArr2, result;
  
    result = {};
  
    tempArr = portfolio.split('\n').map((i) => { return (i === '' ? "\n" : i.trim()); }).map((i) => {
      let arr0, arr1;
      if (/^[0-9]/.test(i) && /[0-9]$/.test(i) && /\-/gi.test(i)) {
        arr0 = i.split('-').map((j) => { return Number(j.trim()); });
        if (arr0.length !== 2) {
          throw new Error("invaild text");
        }
        arr1 = [];
        for (let z = arr0[0]; z < arr0[1] + 1; z++) {
          arr1.push(server + corePortfolio + "/" + self.contents.portfolio.pid + "/" + photoChar + String(z) + self.contents.portfolio.pid + ".jpg" + token + String(z));
        }
        return arr1;
      } else {
        return i;
      }
    });
  
    tempArr = tempArr.flat().map((i) => {
      if (/^http/.test(i)) {
        return [ i.split(token)[0], self.photos.detail[Number(i.split(token)[1]) - 1].gs ];
      } else {
        return i;
      }
    });
  
    tempArr.unshift("\n");
    tempArr.unshift(self.contents.portfolio.title.main);
    result.portfolio = tempArr;
  
    result.review = [];
    if (review !== '') {
  
      tempArr2 = review.split('\n').map((i) => { return (i === '' ? "\n" : i.trim()); }).map((i) => {
        let arr0;
        if (/^[0-9]/.test(i) && /[0-9]$/.test(i)) {
          arr0 = i.split(' ').map((j) => { return Number(j.trim()); });
          arr0 = arr0.map((z) => {
            return server + corePortfolio + "/" + self.contents.portfolio.pid + "/" + photoChar + String(z) + self.contents.portfolio.pid + ".jpg" + token + String(z);
          });
          return arr0;
        } else {
          return i;
        }
      });
  
      tempArr2 = tempArr2.flat().map((i) => {
        if (/^http/.test(i)) {
          return [ i.split(token)[0], self.photos.detail[Number(i.split(token)[1]) - 1].gs ];
        } else {
          return i;
        }
      });
  
      tempArr2.unshift("\n");
      tempArr2.unshift(self.contents.review.title.main);
      result.review = tempArr2;
    }
  
    return result;
  }
  
}

class ContentsArr extends Array {

  toNormal() {
    let tong;
    tong = [];
    for (let i of this) {
      tong.push(i.toNormal());
    }
    return tong;
  }

  getAllPhotos() {
    const path = "/corePortfolio/listImage";
    class PhotoArray extends Array {
      searchByConid(conid) {
        if (typeof conid !== "string") {
          throw new Error("must be conid");
        }
        let result = new PhotoArray();
        for (let i of this) {
          if (i.conid === conid) {
            result.push(i);
          }
        }
        return result;
      }
      searchByRoom(room) {
        if (typeof room !== "string") {
          throw new Error("must be room");
        }
        let result = new PhotoArray();
        for (let i of this) {
          if (i.room === room) {
            result.push(i);
          }
        }
        return result;
      }
    }
    let temp, result;
    result = new PhotoArray();
    for (let { conid, desid, contents: { portfolio, review }, photos } of this) {
      temp = JSON.parse(JSON.stringify(photos)).detail;
      for (let obj of temp) {
        obj.conid = conid;
        obj.desid = desid;
        obj.pid = portfolio.pid;
        obj.pyeong = portfolio.spaceInfo.pyeong;
        obj.room = "review";
        for (let i = 1; i < portfolio.contents.detail.length; i++) {
          if (portfolio.contents.detail[i].photo.includes(obj.index)) {
            obj.room = portfolio.contents.detail[i].title;
          }
        }
        obj.keywords = [];
        for (let t of portfolio.detailInfo.tag) {
          obj.keywords.push(t);
        }
        obj.keywords.push(portfolio.detailInfo.service);
        obj.keywords = obj.keywords.filter((z) => { return z !== '' && z !== "all"; });
        obj.file = `t${String(obj.index)}${obj.pid}.jpg`;
        obj.path = path + "/" + obj.pid + "/" + obj.file;
      }
      result.push(temp);
    }
    result = result.flat();
    return result;
  }

  conidArr(arr, normalMode = false) {
    if (!Array.isArray(arr)) {
      throw new Error("invaild input");
    }
    if (!arr.every((c) => { return typeof c === "string"; })) {
      throw new Error("invaild input");
    }
    let result;
    if (!normalMode) {
      result = new ContentsArr();
      for (let obj of this) {
        if (arr.includes(obj.conid)) {
          result.push(obj);
        }
      }
    } else {
      result = [];
      for (let conid of arr) {
        for (let obj of this) {
          if (conid === obj.conid) {
            result.push(obj.toNormal());
          }
        }
      }
    }
    return result;
  }

}

const withTools = function (Contents) {

  Contents.prototype.flatDeath = function () {
    const contents = this.toNormal();
    const { conid, desid, contents: { portfolio, review }, photos } = contents;
    const { pid, date: portfolioDate, spaceInfo, title, color, detailInfo, contents: portfolioContents } = portfolio;
    const { space, pyeong, region, method } = spaceInfo;
    const { photodae, photosg, slide, tag, service, sort: { key8, key9 } } = detailInfo;
    const { rid, date: reviewDate, title: reviewTitle, detailInfo: reviewDetailInfo, contents: reviewContents } = review;
    const dateToString = function (dateObject, detail = false) {
      let dayString = '';

      dayString += String(dateObject.getFullYear()).slice(0, 4);
      dayString += '-';

      if (dateObject.getMonth() + 1 < 10) {
        dayString += '0' + String(dateObject.getMonth() + 1);
      } else {
        dayString += String(dateObject.getMonth() + 1);
      }

      dayString += '-';

      if (dateObject.getDate() < 10) {
        dayString += '0' + String(dateObject.getDate());
      } else {
        dayString += String(dateObject.getDate());
      }

      if (detail) {
        dayString += ' ';
        if (dateObject.getHours() < 10) {
          dayString += '0' + String(dateObject.getHours());
        } else {
          dayString += String(dateObject.getHours());
        }
        dayString += ':';
        if (dateObject.getMinutes() < 10) {
          dayString += '0' + String(dateObject.getMinutes());
        } else {
          dayString += String(dateObject.getMinutes());
        }
        dayString += ':';
        if (dateObject.getSeconds() < 10) {
          dayString += '0' + String(dateObject.getSeconds());
        } else {
          dayString += String(dateObject.getSeconds());
        }
      }

      if (/^1[678]/.test(dayString)) {
        dayString = '-';
      } else if (/^3/.test(dayString)) {
        dayString = '예정';
      }

      return dayString;
    }

    let tong = [];
    let temp;

    temp = {};
    temp.standard = {
      conid,
      pid
    };
    temp.info = {
      desid,
      rid,
      portfolioDate: dateToString(portfolioDate, true),
      reviewDate: dateToString(reviewDate, true),
      titleMain: title.main,
      titleSub: title.sub,
      reviewTitleMain: reviewTitle.main,
      reviewTitleSub: reviewTitle.sub,
      space,
      pyeong,
      region,
      method,
      color: (color.main + " / " + color.sub + " / " + color.title),
      photodae: photodae.join(", "),
      reviewPhotodae: reviewDetailInfo.photodae.join(", "),
      photosg: (photosg.first + ", " + photosg.last),
      slide: slide.join(", "),
      tag: tag.join(", "),
      service,
      key8,
      key9,
      order: reviewDetailInfo.order,
    };
    tong.push(temp);

    return tong;
  }

  Contents.prototype.dimensionSqueeze = function () {
    const tong = this.flatDeath();
    let result, tempObj;

    result = [];
    for (let { standard, info } of tong) {
      tempObj = {};
      for (let i in standard) {
        tempObj[i] = standard[i];
      }
      for (let i in info) {
        tempObj[i] = info[i];
      }
      tempObj.reviewOrder = tempObj.order;
      delete tempObj.order;
      result.push(tempObj);
    }

    return result;
  }

  Contents.prototype.imagePath = function () {
    class KeyImages {
      toArray() {
        let arr = [];
        let tempObj;
        for (let i in this.rooms) {
          tempObj = {};
          tempObj.pid = this.pid;
          tempObj.room = i;
          tempObj.photos = this.rooms[i];
          arr.push(tempObj);
        }
        return arr;
      }
    }
    class ImagePath {
      keyListImage() {
        const { key: { rooms, photos }, listImage: images } = this;
        let result = new KeyImages();
        result.conid = this.conid;
        result.pid = this.pid;
        result.rooms = {};

        for (let i = 0; i < rooms.length; i++) {
          result.rooms[rooms[i]] = [];
          for (let j = photos[i][0] - 1; j < photos[i][1]; j++) {
            result.rooms[rooms[i]].push(images[j]);
          }
        }
        return result;
      }
      keyOriginal() {
        const { key: { rooms, photos }, original: images } = this;
        let result = new KeyImages();
        result.conid = this.conid;
        result.pid = this.pid;
        result.rooms = {};

        for (let i = 0; i < rooms.length; i++) {
          result.rooms[rooms[i]] = [];
          for (let j = photos[i][0] - 1; j < photos[i][1]; j++) {
            result.rooms[rooms[i]].push(images[j]);
          }
        }
        return result;
      }
    }
    const pid = this.contents.portfolio.pid;
    let result = new ImagePath();
    let tempObj;

    result.conid = this.conid;
    result.pid = pid;
    result.key = this.contents.portfolio.keyMatrix();

    result.listImage = [];
    result.original = [];

    for (let i = 0; i < this.photos.detail.length; i++) {
      tempObj = {};
      tempObj.path = "/corePortfolio/listImage/" + pid + "/t" + this.photos.detail[i].index + pid + ".jpg";
      tempObj.gs = this.photos.detail[i].gs;
      result.listImage.push(tempObj);
      tempObj = {};
      tempObj.path = "/corePortfolio/original/" + pid + "/i" + this.photos.detail[i].index + pid + ".jpg";
      tempObj.gs = this.photos.detail[i].gs;
      result.original.push(tempObj);
    }

    return result;
  }

  return Contents;
}

const withToolsArr = function (ContentsArr) {

  ContentsArr.prototype.flatDeath = function () {
    let tong, tempArr;
    tong = [];
    for (let i of this) {
      tempArr = i.flatDeath();
      for (let j of tempArr) {
        tong.push(j);
      }
    }
    return tong;
  }

  ContentsArr.prototype.dimensionSqueeze = function () {
    const TABLE_NAME = "contents";
    const LONG_TARGETS = [];
    class SqlModel {
      constructor(sample) {
        for (let i in sample) {
          if (typeof sample[i] === "string") {
            this[i] = "VARCHAR(255)";
          } else if (typeof sample[i] === "number") {
            this[i] = "INT(11)";
          } else if (typeof sample[i] === "boolean") {
            this[i] = "INT(11)";
          } else {
            this[i] = "VARCHAR(255)";
          }
          if (LONG_TARGETS.includes(i)) {
            this[i] = "TEXT";
          }
        }
      }

      getName() {
        return TABLE_NAME;
      }

      getCreateSql() {
        let sql = "CREATE TABLE \`" + this.getName() + "\` (";
        sql += "id INT(11) NOT NULL AUTO_INCREMENT,";
        sql += " ";
        for (let i in this) {
          sql += "\`";
          sql += i;
          sql += "\`";
          sql += " ";
          sql += this[i];
          sql += ", ";
        }
        sql += "PRIMARY KEY (id));";
        return sql;
      }

      getDropSql() {
        let sql = "DROP TABLE " + this.getName() + ";";
        return sql;
      }

    }
    class SqlTong extends Array {
      getName() {
        return TABLE_NAME;
      }

      getInsertSql() {
        let arr = [];
        for (let i of this) {
          arr.push(i.getInsertSql());
        }
        return arr;
      }

    }
    class SqlTongFactor {
      constructor(sample) {
        for (let i in sample) {
          if (typeof sample[i] === "string") {
            this[i] = sample[i];
          } else if (typeof sample[i] === "number") {
            this[i] = sample[i];
          } else if (typeof sample[i] === "boolean") {
            if (sample[i]) {
              this[i] = 1;
            } else {
              this[i] = 0;
            }
          } else {
            this[i] = JSON.stringify(sample[i]);
          }
        }
      }

      getName() {
        return TABLE_NAME;
      }

      getInsertSql() {
        let sql = "INSERT INTO \`" + this.getName() + "\` (";
        for (let i in this) {
          sql += "\`";
          sql += i;
          sql += "\`";
          sql += ",";
        }

        sql = sql.slice(0, -1);
        sql += ") VALUES (";

        for (let i in this) {
          if (typeof this[i] === "number") {
            sql += this[i];
          } else {
            if (/^[0-9][0-9][0-9][0-9]\-[0-9][0-9]\-[0-9][0-9]$/gi.test(this[i])) {
              sql += "STR_TO_DATE('";
              sql += this[i].replace(/'/g, '"');
              sql += "', '%Y-%m-%d')";
            } else if (/^[0-9][0-9][0-9][0-9]\-[0-9][0-9]\-[0-9][0-9] [0-9][0-9]\:[0-9][0-9]\:[0-9][0-9]$/gi.test(this[i])) {
              sql += "STR_TO_DATE('";
              sql += this[i].replace(/'/g, '"');
              sql += "', '%Y-%m-%d %H:%i:%s')";
            } else {
              sql += "'";
              sql += this[i].replace(/'/g, '"');
              sql += "'";
            }
          }
          sql += ",";
        }

        sql = sql.slice(0, -1);
        sql += ");";

        return sql;
      }
    }

    let tong, tempArr;
    let sample, model;

    tong = new SqlTong();

    for (let i of this) {
      tempArr = i.dimensionSqueeze();
      for (let j of tempArr) {
        tong.push(new SqlTongFactor(j));
      }
    }

    if (tong.length > 0) {
      sample = tong[0];
      model = new SqlModel(sample);
      return { model, data: tong };
    } else {
      return null;
    }
  }

  ContentsArr.prototype.search = function (conid) {
    let result = null;
    for (let i of this) {
      if (i.conid === conid) {
        result = i;
        break;
      }
    }
    return result;
  }

  ContentsArr.prototype.find = function (conid) {
    return this.search(conid);
  }

  ContentsArr.prototype.imagePath = function () {
    class ImageArray extends Array {
      convertConid() {
        let result = {};
        for (let i of this) {
          result[i.conid] = i;
        }
        return result;
      }
      convertPid() {
        let result = {};
        for (let i of this) {
          result[i.pid] = i;
        }
        return result;
      }
      flatListImage() {
        let result = [];
        for (let i of this) {
          for (let j of i.listImage) {
            result.push(j.path);
          }
        }
        return result;
      }
      flatOriginal() {
        let result = [];
        for (let i of this) {
          for (let j of i.original) {
            result.push(j.path);
          }
        }
        return result;
      }
      keyListImage() {
        let result = [];
        let tempArr;
        for (let i of this) {
          tempArr = i.keyListImage().toArray();
          result = result.concat(tempArr);
        }
        return result;
      }
      keyOriginal() {
        let result = [];
        let tempArr;
        for (let i of this) {
          tempArr = i.keyOriginal().toArray();
          result = result.concat(tempArr);
        }
        return result;
      }
    }
    let result = new ImageArray();
    for (let i of this) {
      result.push(i.imagePath());
    }
    return result;
  }
  return ContentsArr;
}

module.exports = { ContentsMap, Contents, ContentsArr, Tools: { withTools, withToolsArr } };